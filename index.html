<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Tic-Tac-Toe with Gemini AI</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            color: #333;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 10px;
            background-color: #34495e;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .cell {
            width: 100px;
            height: 100px;
            background-color: #ecf0f1;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .cell:hover { background-color: #bdc3c7; }
        .cell.x { color: #3498db; }
        .cell.o { color: #e74c3c; }
        .winning-cell {
            background-color: #2ecc71 !important;
            color: white !important;
        }
        #status {
            margin-top: 25px;
            font-size: 1.5rem;
            font-weight: 600;
            min-height: 30px; /* Use min-height to prevent layout shift */
            transition: color 0.5s ease;
            text-align: center;
        }
        .status-win { color: #2ecc71; }
        .status-lose { color: #e74c3c; }
        .status-draw { color: #f39c12; }

        .button-group {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .gemini-button, #reset-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(50,50,93,.11), 0 1px 3px rgba(0,0,0,.08);
        }
        #reset-button { background-color: #3498db; }
        #reset-button:hover { background-color: #2980b9; transform: translateY(-2px); }
        
        .gemini-button { background-color: #8e44ad; }
        .gemini-button:hover { background-color: #732d91; transform: translateY(-2px); }
        .hidden { display: none; }

        #analysis-container {
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
        }
        #analysis-container h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tic-Tac-Toe</h1>
        <div id="game-board"></div>
        <p id="status"></p>
        <div class="button-group">
            <button id="reset-button">New Game</button>
            <button id="get-taunt-button" class="gemini-button hidden">✨ Get AI Taunt</button>
            <button id="analyze-game-button" class="gemini-button hidden">✨ Analyze Game</button>
        </div>
        <div id="analysis-container" class="hidden">
            <h3>✨ Game Analysis</h3>
            <div id="analysis-result"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('game-board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const getTauntButton = document.getElementById('get-taunt-button');
        const analyzeGameButton = document.getElementById('analyze-game-button');
        const analysisContainer = document.getElementById('analysis-container');
        const analysisResult = document.getElementById('analysis-result');

        // --- Game State ---
        let board, gameActive, moveHistory;
        const humanPlayer = 'X';
        const aiPlayer = 'O';

        // --- Initialize Game ---
        function initializeGame() {
            board = [['', '', ''], ['', '', ''], ['', '', '']];
            gameActive = true;
            moveHistory = [];
            statusElement.textContent = "Your turn (X)";
            statusElement.className = '';
            getTauntButton.classList.add('hidden');
            analyzeGameButton.classList.add('hidden');
            analysisContainer.classList.add('hidden');
            analysisResult.innerHTML = '';
            renderBoard();
        }

        // --- Render Board ---
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[i][j] === 'X') cell.classList.add('x');
                    if (board[i][j] === 'O') cell.classList.add('o');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.textContent = board[i][j];
                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
            }
        }

        // --- Handle Player's Move ---
        async function handleCellClick(event) {
            if (!gameActive) return;
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (board[row][col] === '') {
                board[row][col] = humanPlayer;
                moveHistory.push({ player: humanPlayer, move: [row, col] });
                renderBoard();

                if (getWinner(board)) {
                    endGame();
                    return;
                }
                
                getTauntButton.classList.remove('hidden');
                gameActive = false;
                statusElement.textContent = "AI is thinking...";
                setTimeout(aiMove, 500);
            }
        }

        // --- AI's Move ---
        function aiMove() {
            if (getWinner(board)) { 
                endGame();
                return;
            }
            const bestMove = findBestMove();
            if (bestMove) {
                board[bestMove.row][bestMove.col] = aiPlayer;
                moveHistory.push({ player: aiPlayer, move: [bestMove.row, bestMove.col] });
            }
            renderBoard();
            
            if (getWinner(board)) {
                endGame();
            } else {
                gameActive = true;
                statusElement.textContent = "Your turn (X)";
            }
        }
        
        // --- Minimax Algorithm (Unchanged) ---
        function findBestMove() {
            let bestScore = -Infinity;
            let move = null;
            for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) {
                if (board[i][j] === '') {
                    board[i][j] = aiPlayer;
                    let score = minimax(board, 0, false);
                    board[i][j] = '';
                    if (score > bestScore) {
                        bestScore = score;
                        move = { row: i, col: j };
                    }
                }
            }
            return move;
        }

        const scores = { 'O': 10, 'X': -10, 'tie': 0 };

        function minimax(currentBoard, depth, isMaximizing) {
            let result = getWinner(currentBoard);
            if (result !== null) return scores[result.winner];

            let bestScore = isMaximizing ? -Infinity : Infinity;
            for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) {
                if (currentBoard[i][j] === '') {
                    currentBoard[i][j] = isMaximizing ? aiPlayer : humanPlayer;
                    let score = minimax(currentBoard, depth + 1, !isMaximizing);
                    currentBoard[i][j] = '';
                    bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);
                }
            }
            return bestScore;
        }

        // --- Game Over Logic ---
        function getWinner(currentBoard) {
            const lines = [
                [[0,0], [0,1], [0,2]], [[1,0], [1,1], [1,2]], [[2,0], [2,1], [2,2]],
                [[0,0], [1,0], [2,0]], [[0,1], [1,1], [2,1]], [[0,2], [1,2], [2,2]],
                [[0,0], [1,1], [2,2]], [[0,2], [1,1], [2,0]]
            ];
            for (const line of lines) {
                const [a, b, c] = line;
                const valA = currentBoard[a[0]][a[1]];
                if (valA !== '' && valA === currentBoard[b[0]][b[1]] && valA === currentBoard[c[0]][c[1]]) {
                    return { winner: valA, line: line };
                }
            }
            if (currentBoard.flat().every(cell => cell !== '')) return { winner: 'tie' };
            return null;
        }

        function endGame() {
            gameActive = false;
            getTauntButton.classList.add('hidden');
            const result = getWinner(board);
            if (!result) return; // Safeguard against null result

            if (result.winner === 'tie') {
                statusElement.textContent = "It's a Draw!";
                statusElement.classList.add('status-draw');
                analyzeGameButton.classList.remove('hidden');
            } else {
                statusElement.textContent = `${result.winner} Wins!`;
                statusElement.classList.add(result.winner === humanPlayer ? 'status-win' : 'status-lose');
                if (result.winner === aiPlayer) {
                    analyzeGameButton.classList.remove('hidden');
                }
                if (result.line) {
                    result.line.forEach(pos => {
                        const cell = document.querySelector(`[data-row='${pos[0]}'][data-col='${pos[1]}']`);
                        if (cell) {
                           cell.classList.add('winning-cell');
                        }
                    });
                }
            }
        }

        // --- Gemini API Integration ---
        async function callGemini(prompt, element) {
            element.innerHTML = '<div class="loader"></div>';

            const apiKey = ""; // Will be provided by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }]
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorBody = await response.text();
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}.`;
                     try {
                        const errorJson = JSON.parse(errorBody);
                        if(errorJson.error && errorJson.error.message) {
                            errorMessage = errorJson.error.message;
                        } else {
                            errorMessage += ` Response: ${errorBody}`;
                        }
                    } catch(e) {
                         errorMessage += ` Response: ${errorBody}`;
                    }
                    throw new Error(`API Error: ${errorMessage}`);
                }

                const result = await response.json();
                
                if (!result.candidates || result.candidates.length === 0 || !result.candidates[0].content || !result.candidates[0].content.parts) {
                    throw new Error("Invalid response structure from API.");
                }

                const text = result.candidates[0].content.parts[0].text;
                element.innerHTML = text.replace(/\n/g, '<br>');
            } catch (error) {
                console.error("Gemini API call failed:", error);
                element.textContent = "Sorry, I'm speechless right now. Please try again.";
            }
        }

        getTauntButton.addEventListener('click', async () => {
            getTauntButton.classList.add('hidden');
            const boardString = board.map(row => row.map(cell => cell || ' ').join(', ')).join('; ');
            const prompt = `You are a witty, slightly arrogant Tic-Tac-Toe AI. The human player ('X') just made a move. The current board is: ${boardString}. Give a short, clever taunt (1-2 sentences) about their move or the state of the game.`;
            await callGemini(prompt, statusElement);
        });

        analyzeGameButton.addEventListener('click', async () => {
            analysisContainer.classList.remove('hidden');
            const movesString = moveHistory.map(m => `${m.player} to [${m.move}]`).join(', ');
            const result = getWinner(board);
            if(!result) return; // Safeguard
            const prompt = `You are a Tic-Tac-Toe expert analyzing a game. The human was 'X', the AI was 'O'. The game ended in a ${result.winner === 'tie' ? 'draw' : 'loss for the human'}. The sequence of moves was: ${movesString}. 
            
            Please provide a brief analysis:
            1. Point out the human's critical mistake.
            2. Explain why it was a mistake.
            3. Suggest what they should have done instead.
            
            Keep the tone helpful and encouraging.`;
            await callGemini(prompt, analysisResult);
        });

        // --- Event Listeners & Initial Start ---
        resetButton.addEventListener('click', initializeGame);
        window.onload = initializeGame;
    </script>
</body>
</html>
